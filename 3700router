#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math

class Router:

    relations = {}
    sockets = {}
    ports = {}
    forward_table = {}
    table_cache = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        print("Sent %s", message)
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def count_consecutive_ones(self, ip_address):
        ip_parts = ip_address.split('.')
        
        binary_parts = []
        for part in ip_parts:
            binary_parts.append(bin(int(part))[2:].zfill(8))
        
        ip_binary = ''.join(binary_parts)
        ones = 0
        
        # Iterate through each character in the combined binary representation
        for bit in ip_binary:
            if bit == '1':
                ones += 1
            else:
                break
        
        return ones

    def parse_update(self, json_message):
        decoded = json_message.copy()
        network = decoded['msg']['network']
        netmask = decoded['msg']['netmask']
        src = decoded['src']
        as_path = [args.asn]
        for i in decoded['msg']['ASPath']:
            as_path.append(i)
        # the message to be added is just the old one, but we add a 'peer' field
        # peer = source IP of the router that sent the corresponding update message
        new_entry = decoded['msg']
        new_entry['peer'] = src
        
        self.forward_table[src] = (network, self.count_consecutive_ones(netmask))
        
        self.table_cache.append(new_entry.copy())
        
        message_dict = {"msg": {"netmask": netmask, "ASPath": as_path, "network": network},
                        "src": "placeholder", "dst": "placeholder", "type": "update"}
        
        self.forward_message(message_dict, src)
    
    def forward_message(self, message, src):
        flag = 0 if self.relations[src] == 'cust' else 1
        for sock in self.sockets:
            if sock != src and (flag == 0 or (flag == 1 and self.relations[sock] == 'cust')):
                message['src'] = str(sock)[:-1] + '1'
                message['dst'] = str(sock)
                self.send(sock, json.dumps(message))
    
    def find_ip_address_with_consecutive_ones(self, ones):
    
        binary = []
        i = 0
        while ones >= 8:
            binary.append(8)
            ones -= 8
        
        binary.append(ones)

        while len(binary) < 4:
            binary.append(0)
        
        IP = []
        
        for b in binary:
            IP.append(('1' * b) + ('0' * (8 - b)))
        print(IP)
        for i in range(len(IP)):
            x = int(IP[i], 2)
            IP[i] = f"{x}"
        
        return ".".join(IP)
    
    def decimal_to_binary(self, decimal_number):
        # Get the binary representation with '0b' prefix
        binary_str = bin(decimal_number)
        # Remove the '0b' prefix
        binary_str = binary_str[2:]
        # Ensure the binary string is exactly 8 bits long by padding with zeros if necessary
        binary_str = binary_str.zfill(8)
        return binary_str
    
    def is_match(self, candidateIP, network, mask: int):
        
        candidateIP = [self.decimal_to_bianry(val) for val in candidateIP.split(".")]
        networkIP = [self.decimal_to_bianry(val) for val in network.split(".")]
        i = 0
        while mask >= 8:
            if candidateIP[i][:8] == networkIP[i][:8]:
                mask -= 8
            i += 1
        return candidateIP[i][:mask] == networkIP[i][:mask]
    
    
        
    
    def handle_data(self, message):
        src = message['src']
        dst = message['dst'].split('.')
        dst = dst[:-1] + ['2']
        dst = '.'.join(dst)
        msg = message['msg']
        
        send_msg = {"src": src, "dst": dst, "type": "data", "msg": msg}
        self.send(dst, send_msg)
        return
        
        self.send()
         
    def handle_dump(self, message):
        
        self.send(message["src"], json.dumps({"src": message["dst"], "dst": message["src"], "type": "table", "msg": self.table_cache.copy()}))
        # pass
    
    def process_message(self, message):
        msg_type = message["type"]
        
        if msg_type == "handshake":
            pass
        
        if msg_type == "update":
            self.parse_update(message)
        
        if msg_type == "withdraw":
            pass
        
        if msg_type == "data":
            # self.handle_data(message)
            pass
        
        if msg_type == "dump":
            # print("DUMP DUMP DUMP DUMP DUMP ", message)
            self.handle_dump(message)
            # pass
            
    
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                self.process_message(json.loads(msg)) # we send message to be dealt with
                
                print("Received message '%s' from %s" % (msg, srcif))
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()