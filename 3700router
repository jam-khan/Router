#!/usr/bin/env -S python3 -u

import argparse, socket, json, select

def get_ip_value(ip):
    
    ip_vals = ip.split('.')
    ip_vals = [int(ip_val) for ip_val in ip_vals]
    
    return sum(ip_vals)
    
# Returns binary string of length 32 with specific 1s from left and remaining bits are 0s
def get_binary_mask(mask):
    # We assume IPv4 address
    return ('1' * mask) + ('0' * (32 - mask))
    
# Takes IP String and returns 32 bit Binary
def ip_to_binary(ip: str):
    
    ip_vals = ip.split('.')
    ip_bin = [bin(int(x))[2:].zfill(8) for x in ip_vals]
    
    return ''.join(ip_bin)

def bin_to_ip(bin_ip):
    
    ip = []
    for i in range(4):
        ip.append(bin_ip[8*i:8*(i + 1)])
    
    return '.'.join([str(bin_to_dec(val)) for val in ip])

def bin_to_dec(bin_digit: str):
    
    bin_digit = bin_digit[::-1]
    
    total = 0
    
    for i in range(len(bin_digit)):
        if bin_digit[i] == '1':
            total += 2**i
    
    return total
    
# Takes 2 binary strings and performs
# and operation and returns result.
def and_bin_str(bin1, bin2):
    
    if len(bin1) != len(bin2):
        return -1 # error
    
    i = 0
    res = list(bin1)
    while i < len(bin2):
        if bin2[i] == '0':
            res[i] = '0'
        
        i += 1
    
    return ''.join(res)

# Takes an ip address and returns consecutive ones
# from left till 0 is detected
def count_consecutive_ones(ip_address):
    
    ip_binary = ip_to_binary(ip_address)
    ones = 0
    
    for bit in ip_binary:
        if bit == '0':
            break
        ones += 1
    
    return ones

# gets 2 ip addresses applies mask on both and compares result
# if same then within network
def is_within_network(ip, network, mask):
    
    mask_bin = get_binary_mask(mask)
    ip_binary1 = ip_to_binary(ip)
    ip_binary2 = ip_to_binary(network)
    
    return and_bin_str(ip_binary1, mask_bin) == and_bin_str(ip_binary2, mask_bin)

def prefix_match(ip, network, mask):
    
    bin_mask    = get_binary_mask(mask)
    bin_network = ip_to_binary(network)
    bin_ip      = ip_to_binary(ip)
    
    res = and_bin_str(bin_network, bin_mask)
    
    prefix_match = 0
    for d1, d2 in zip(res, bin_ip):
        if d1 == d2:
            prefix_match += 1
    
    return prefix_match

#converting ip string in binary back to its ip address format  
def binary_to_ip(binary):
        ip_chunks = [binary[i:i+8] for i in range(0, len(binary), 8)]
        ip_decimals = [str(int(chunk, 2)) for chunk in ip_chunks]
        return '.'.join(ip_decimals)
    

class Router:

    relations = {}
    sockets = {}
    ports = {}
    forward_table = []
    record = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        print(f"Sent: {message}")
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))
        
    # Handling update message
    def handle_update(self, json_message):
        message = json_message.copy()
        network = message['msg']['network']
        netmask = message['msg']['netmask']
        src = message['src']
        as_path = [self.asn] + message['msg']['ASPath']
        
        
        msg = message['msg']
        msg['peer'] = src
        
        self.aggregate(msg.copy())
        
        print("Forwarding table", self.forward_table)
        
        new_msg = {"netmask": netmask, "network": network, "ASPath": as_path}
        
        for sock in self.sockets:
            if sock != src:
                message = {
                    'src': str(sock)[:-1] + '1',
                    'dst': str(sock),
                    'type': 'update',
                    'msg': new_msg
                }
                self.forward_message(message, src)
                # self.send(sock, json.dumps(message))
    
    def find_route(self, dst):
        all_routes = []
        
        for msg in self.forward_table:
            network, netmask = msg['network'], msg['netmask']
            mask = count_consecutive_ones(netmask)
            
            if is_within_network(dst, network, mask):
                all_routes.append(msg)
        
        no_of_routes = len(all_routes)
        
        if no_of_routes == 1:
            return all_routes[0]
        
        if no_of_routes == 0:
            return -1
        
        if no_of_routes == 2:
            route1, route2 = all_routes
            network1, mask1 = route1['network'], count_consecutive_ones(route1['netmask'])
            network2, mask2 = route2['network'], count_consecutive_ones(route2['netmask'])
            
            if prefix_match(dst, network1, mask1) > prefix_match(dst, network2, mask2):
                return route1
            else:
                return route2
            
            
        potential_routes = all_routes
        # else, we go forward and do a filter based on netmask
        mask_lengths = [count_consecutive_ones(route['netmask']) for route in potential_routes]
        # We will only keep matches with max match.
        filtered_routes = []
        for i in range(len(mask_lengths)):
            if mask_lengths[i] == max(mask_lengths):
                filtered_routes.append(potential_routes[i])
        
        potential_routes = filtered_routes
        
        if len(potential_routes) == 1:
            return potential_routes[0]
        
        # After filter has been completed for netmask,
        # we do a filter on localprefs
        # we get max localpref
        
        local_pref = [route['localpref'] for route in potential_routes]

        filtered_routes = []
        for i in range(len(potential_routes)):
            if local_pref[i] == max(local_pref):
                filtered_routes.append(potential_routes[i])
        
        potential_routes = filtered_routes
        if len(potential_routes) == 1:
            return potential_routes[0]
        
        # After performing check on localpref, we go forward and do a check
        # on self origin, where routes with 'True' self origin are preferred.
        
        filtered_routes = []
        for route in potential_routes:
            if route['selfOrigin']:
                filtered_routes.append(route)
        
        if not filtered_routes:
            filtered_routes = []
            for route in potential_routes:
                if not route['selfOrigin']:
                    filtered_routes.append(route)
        
        if len(filtered_routes) == 1:
            return filtered_routes[0]
        
        potential_routes = filtered_routes
        
        # Now, we have performed filter on selfOrigin
        # if still not found a single route, we will
        # perform a filter on ASPath
        ASPath_lengths = [len(route['ASPath']) for route in potential_routes]
        min_path_length = min(ASPath_lengths)
        
        filtered_routes = []
        for i in range(len(potential_routes)):
            if ASPath_lengths[i] == min_path_length:
                filtered_routes.append(potential_routes[i])
        
        potential_routes = filtered_routes
        
        if len(potential_routes) == 1:
            return potential_routes[0]
        
        # Now, we have filtered routes with shortest ASPath
        # If still, we haven't returned, then we will filter
        # using 'origin'
        
        # Correct below filter
        filtered_routes_IGP = []
        filtered_routes_EGP = []
        filtered_routes_UNK = []
        for route in potential_routes:
            if route['origin'] == 'IGP':
                filtered_routes_IGP.append(route)
            elif route['origin'] == 'EGP':
                filtered_routes_EGP.append(route)
            else:
                filtered_routes_UNK.append(route)
        
        filtered_routes = []
        if len(filtered_routes_IGP) != 0:
            filtered_routes = filtered_routes_IGP
        elif len(filtered_routes_EGP) != 0:
            filtered_routes = filtered_routes_EGP
        elif len(filtered_routes_UNK) != 0:
            filtered_routes = filtered_routes_UNK
            
        
        if len(filtered_routes) == 1:
            return filtered_routes_IGP[0]
        
        return filtered_routes[0]
    
    
    
    def forward_message(self, message, src):
        flag = 0 if self.relations[src] == 'cust' else 1
        for sock in self.sockets:
            if sock != src and (flag == 0 or (flag == 1 and self.relations[sock] == 'cust')):
                message['src'] = str(sock)[:-1] + '1'
                message['dst'] = str(sock)
                self.send(sock, json.dumps(message))
    
    def handle_withdraw(self, message):
        
        decoded = message.copy()
        src = decoded['src']
        dst = decoded['dst']
        
        if dst != 0:
            
            for withdrawn in decoded['msg']:
                for entry in self.forward_table:
                    
                    if entry['network'] == withdrawn['network'] \
                        and entry['peer'] == src \
                            and entry['netmask'] == withdrawn['netmask']:
                                
                                self.forward_table.remove(entry)
            
            self.forward_message(message.copy(), src)
        
        self.disaggregate(message.copy())
    
    def aggregate(self, entry):
        
        i = 0
        while i < len(self.forward_table):
            did_aggregate = False
            existing = self.forward_table[i]
            prefix = ip_to_binary(entry['network'])
            mask = count_consecutive_ones(entry['netmask'])
            
            curr_prefix = ip_to_binary(existing['network'])
            curr_mask = count_consecutive_ones(entry['netmask'])
            
            bin1, bin2 = curr_prefix[:curr_mask], prefix[:mask]
            
            is_numerically_adjacent = len(bin1) != 0 and \
                                        len(bin2) != 0 and \
                                            bin1[:-1] == bin2[:-1] and \
                                                bin1[-1] != bin2[-1]
            
            equal_attributes =  entry['localpref']   == existing['localpref']    and\
                                entry['peer']        == existing['peer']         and\
                                entry['origin']      == existing['origin']       and\
                                entry['ASPath']      == existing['ASPath']       and\
                                entry['selfOrigin']  == existing['selfOrigin']
                                
            if is_numerically_adjacent \
                and equal_attributes:
                    prefix = prefix[:mask - 1] + '0' + prefix[mask:]
                    
                    entry['network'] = bin_to_ip(prefix)
                    entry['netmask'] = bin_to_ip(get_binary_mask(mask - 1))
                    
                    self.forward_table.pop(i)
                    did_aggregate = True
            
            if not did_aggregate:
                i += 1
            else:
                i = 0
            
        self.forward_table.append(entry)
            
        
    def disaggregate(self, message):
        
        self.forward_table = []
        
        for withdrawn in message['msg']:
            for entry in self.record:
                
                if entry['msg']['network'] == withdrawn['network'] \
                    and entry['msg']['netmask'] == withdrawn['netmask'] \
                        and entry['msg']['peer'] == message['src']:
                            self.record.remove(entry)
        
        for backup in self.record:
            temp = backup['msg']
            temp['peer'] = backup['src']
            self.aggregate(temp.copy())
            
            
    
    # Handling data message
    def handle_data(self, message, srcif):
        
        src = message['src']
        dst = message['dst']
        msg = message['msg']
        
        nei = self.find_route(dst)
        
        if nei != -1:
            router = nei['peer']
            
            if self.relations[router] == 'cust' or self.relations[srcif] == 'cust':
                self.send(router, json.dumps({"src": src, "dst": dst, "type": "data", "msg": msg}))
        
        else:
            self.send(srcif, json.dumps({
                "src": self.our_addr(str(srcif)),
                "dst": src,
                "type": "no route",
                "msg": {}}))
                
    def handle_dump(self, message):
        self.send(message["src"], json.dumps({"src": message["dst"], "dst": message["src"], "type": "table", "msg": self.forward_table.copy()}))
        
    def process_message(self, message, srcif):
        
        msg_type = message["type"]
        
        if msg_type == "handshake":
            pass
        elif msg_type == "update":
            self.record.append(message.copy())
            self.handle_update(message)
        elif msg_type == "withdraw":
            self.handle_withdraw(message)
            pass
        elif msg_type == "data":
            self.handle_data(message, srcif)
        elif msg_type == "dump":
            self.handle_dump(message)
    
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                
                print(f"Received {msg}")

                self.process_message(json.loads(msg), srcif) # we send message to be dealt with
                
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()