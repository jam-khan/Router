#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math


# Returns binary string of length 32 with
# specific 1s from left and remaining bits are 0s
def get_binary_mask(mask):
    # We assume IPv4 address

    return ('1' * mask) + ('0' * (32 - mask))
    
# Takes IP String and returns 32 bit Binary
def ip_to_binary(ip: str):
    
    ip_vals = ip.split('.')
    ip_bin = [bin(int(x))[2:].zfill(8) for x in ip_vals]
    
    return ''.join(ip_bin)

# Takes 2 binary strings and performs
# and operation and returns result.
def and_bin_str(bin1, bin2):
    
    if len(bin1) != len(bin2):
        return -1 # error
    
    i = 0
    res = list(bin1)
    while i < len(bin2):
        if bin2[i] == '0':
            res[i] = '0'
        
        i += 1
    
    return ''.join(res)

# Takes an ip address and returns consecutive ones
# from left till 0 is detected
def count_consecutive_ones(ip_address):
    
    ip_binary = ip_to_binary(ip_address)
    ones = 0
    
    for bit in ip_binary:
        if bit == '0':
            break
        ones += 1
    
    return ones

# gets 2 ip addresses
# applies mask on both and compares result
# if same then within network
def is_within_network(ip, network, mask):
    
    mask_bin = get_binary_mask(mask)
    ip_binary1 = ip_to_binary(ip)
    ip_binary2 = ip_to_binary(network)
    
    return and_bin_str(ip_binary1, mask_bin) == and_bin_str(ip_binary2, mask_bin)


class Router:

    relations = {}
    sockets = {}
    ports = {}
    forward_table = {}
    table_cache = []

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        print(f"Sent: {message}")
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    # Handling update message
    def handle_update(self, json_message):
        message = json_message.copy()
        network = message['msg']['network']
        netmask = message['msg']['netmask']
        src = message['src']
        as_path = [self.asn] + message['msg']['ASPath']
        
        msg = message['msg']
        msg['peer'] = src
        
        self.forward_table[src] = self.forward_table.get(src, [])
        self.forward_table[src].append((network, count_consecutive_ones(netmask)))
        # One src/port can handle multiple destination networks.
        
        print("Forwarding table", self.forward_table)
        self.table_cache.append(msg.copy())
        
        new_msg = {"netmask": netmask, "network": network, "ASPath": as_path}
        
        for sock in self.sockets:
            if sock != src:
                message = {
                    'src': str(sock)[:-1] + '1',
                    'dst': str(sock),
                    'type': 'update',
                    'msg': new_msg
                }
                
                self.send(sock, json.dumps(message))
    
    def find_route(self, dst):
        
        for neighbour in self.forward_table:
            for network, mask in self.forward_table[neighbour]:
                if is_within_network(dst, network, mask):
                    return neighbour
        
        return -1
    # Handling data message
    def handle_data(self, message, srcif):
        
        # src = message['src']
        dst = message['dst']
        msg = message['msg']
        
        nei = self.find_route(dst)
        
        if nei != -1: 
            self.send(nei, json.dumps({"src": self.our_addr(nei), "dst": dst, "type": "data", "msg": msg}))
        
        # This code needs to be tested.
        self.send(srcif, json.dumps({
            "src": self.our_addr(str(srcif)),
            "dst": str(srcif),
            "type": "no route",
            "msg": {}}))
        
    def handle_dump(self, message):
        self.send(message["src"], json.dumps({"src": message["dst"], "dst": message["src"], "type": "table", "msg": self.table_cache.copy()}))
        
    def process_message(self, message, srcif):
        msg_type = message["type"]
        
        if msg_type == "handshake":
            pass
        elif msg_type == "update":
            self.handle_update(message)
        elif msg_type == "withdraw":
            
            # In this case, we need to handle
            # it in following manner:
            # 1. Save a copy of the revocation
            # 2. Remove Dead Entry
            # 3. Send copies of the revocation to neighbouring routers
            pass
        elif msg_type == "data":
            self.handle_data(message, srcif)
            pass
        elif msg_type == "dump":
            self.handle_dump(message)
    
    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')
                
                print(f"Received {msg}")

                self.process_message(json.loads(msg), srcif) # we send message to be dealt with
                
        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()